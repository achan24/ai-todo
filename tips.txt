SQLite Migration Tips
====================

1. SQLite Limitations
-------------------
- SQLite DOES NOT support ALTER TABLE for:
  * Adding constraints (like NOT NULL)
  * Changing column types
  * Renaming columns
  * Dropping columns

2. Correct Migration Pattern for SQLite
------------------------------------
When needing to modify tables, ALWAYS use this pattern:
1. Drop temporary tables if they exist from previous failed migrations
2. Create new table with desired schema
3. Copy data from old table to new table (use COALESCE for NULL values)
4. Drop old table
5. Rename new table to original name

Example:
```python
# Clean up any failed migrations
op.execute('DROP TABLE IF EXISTS table_new')

# Create new table
op.create_table(
    'table_new',
    sa.Column('id', sa.Integer(), nullable=False),
    # ... other columns
)

# Copy data with NULL handling
op.execute('''
    INSERT INTO table_new 
    SELECT 
        id,
        COALESCE(nullable_field, default_value),
        other_field 
    FROM table
''')

# Drop old table
op.drop_table('table')

# Rename new table
op.rename_table('table_new', 'table')
```

3. DateTime Fields in SQLite
-------------------------
- Always use server_default for created_at and updated_at
- Correct format:
  ```python
  created_at = Column(DateTime(timezone=True), 
                     server_default=sa.text('CURRENT_TIMESTAMP'),
                     nullable=False)
  updated_at = Column(DateTime(timezone=True),
                     server_default=sa.text('CURRENT_TIMESTAMP'),
                     onupdate=sa.text('CURRENT_TIMESTAMP'),
                     nullable=False)
  ```

4. Foreign Keys
-------------
- Always specify ondelete behavior
- Example:
  ```python
  parent_id = Column(Integer, ForeignKey('parent.id', ondelete='CASCADE'))
  ```

5. Common Gotchas
---------------
- Always handle nullable fields explicitly with COALESCE in migrations
- Use Text type for long string fields
- Remember to create indexes where needed
- SQLite treats booleans as integers
- When adding NOT NULL constraints, provide default values for existing NULL data
- Always clean up temporary tables from failed migrations with DROP TABLE IF EXISTS

6. Model Creation
----------------
ALWAYS CHECK EXISTING MODELS BEFORE CREATING NEW ONES:
- The Metric model already exists in models/goal.py
- Don't create duplicate models in separate files
- Look through existing code thoroughly before making changes

7. Model Organization
-------------------
- Models should be defined in a single location to avoid duplicate table definitions in SQLAlchemy
- If a model is closely related to another (like Metric is to Goal), define it in the same file
- Import models through __init__.py to maintain clean imports (e.g., from ..models import Metric instead of from ..models.metric import Metric)

8. Component Naming Consistency
----------------------
- NEVER have multiple components that do the same thing with different names (e.g. EditTaskModal vs EditTaskDialog)
- Pick ONE clear, descriptive name and stick with it throughout the app
- Bad: Having EditTaskModal.tsx and EditTaskDialog.tsx doing the same thing
- Good: Pick EditTaskDialog.tsx and use it everywhere - the name describes what it does, not how it looks
- This makes the codebase more intuitive and prevents confusion when adding new features

9. Don't fucking rename anything unless specifically asked to and permission is given.

10. Metric model is in Goal model.

11. Alembic Migration Tips
----------------------
- When a migration fails, check for leftover temporary tables (e.g. tasks_new) from previous attempts and clean them up
- For SQLite migrations that modify tables:
  1. Create a new table with the desired schema
  2. Copy all data from old table to new, being explicit about column order
  3. Drop the old table
  4. Rename the new table to the original name
- Index names must be unique across the entire database
- Always handle both upgrade() and downgrade() paths in migrations
- Test migrations on a copy of the database first
- When copying data between tables, explicitly list all columns to avoid issues with schema changes

12. SCHEMA CHANGES:
- NEVER change a schema unless a property literally doesn't exist
- Instead of changing schemas, use helper functions/properties to adapt the data
- Migrations are WAY more complicated and risky than just adapting the data in code
- If data format needs to change, handle it in the service layer, not by modifying the schema

13. API Endpoint Design
---------------------

1. DO NOT create separate endpoints for variations of the same action
   BAD: 
   - /tasks/{id}/update
   - /tasks/{id}/complete (for tasks with metrics)
   - /tasks/{id}/complete-simple (for tasks without metrics)
   
   GOOD:
   - Single /tasks/{id} PUT endpoint that handles all update cases
   - Let the payload determine what gets updated (completion status, metric data, etc.)

2. Keep the API surface minimal and consistent
   - One resource = One endpoint
   - Use HTTP methods (GET, POST, PUT, DELETE) to differentiate actions
   - Let request/response schemas handle variations in data

3. Example:
   Instead of special /complete endpoint, just use PUT with all necessary data:
   PUT /tasks/{id}
   {
     "completed": true,
     "metric_id": 123,        // Optional
     "contribution_value": 5   // Optional
   }

14. Database and Scripts
---------------------

1. Database file location:
   - The app uses SQLite with file: ./sql_app.db
   - When writing scripts, ALWAYS use the same database file as the main app:
     ```python
     DATABASE_URL = "sqlite:///./sql_app.db"  # NOT some other random path
     ```
   - If your script can't find tables, you're probably looking at the wrong database file

2. Writing Database Scripts:
   - Import all related models (including ones used in relationships)
   - Create tables if they don't exist: Base.metadata.create_all(bind=engine)
   - Use the same database URL as the main app
   - Test the script with a small subset of data first

15. Before Adding New Features
-------------------------

1. ALWAYS check if the functionality already exists:
   - Search through the codebase for relevant endpoints and components
   - Check both frontend and backend implementations
   - Look for similar patterns that might already handle the use case
   - Don't waste time implementing something that's already there

2. If adding new functionality:
   - Document where you looked and what's missing
   - Explain why the existing code can't handle the use case
   - Then proceed with the implementation

16. Function Naming Consistency
-------------------------

1. Keep function names consistent with their purpose and UI:
   - If a button says "Edit", the handler should be "handleEdit..."
   - If a button says "Add", the handler should be "handleAdd..."
   - Don't introduce new variations like "create", "save", "update" for the same action
   - Bad: handleCreateStrategy when the UI says "Add Strategy"
   - Good: handleAddStrategy for "Add Strategy" button
   - Good: handleEditStrategy for "Edit Strategy" button

2. Follow the established pattern in the codebase:
   - Look at similar features to maintain consistency
   - Don't mix different naming conventions for the same type of action

17. API Endpoints and URLs
-------------------------

1. NEVER hardcode URLs or API endpoints:
   - Don't use absolute URLs like "http://localhost:8005/api/..."
   - Use relative URLs like "/api/..." that will work in any environment
   - This ensures the app can be deployed without code changes

2. Be consistent with URL patterns:
   - Use the same URL structure throughout the application
   - If using relative URLs, use them everywhere
   - Don't mix relative and absolute URLs

18. Configuration Management
-------------------------

1. NEVER hardcode configuration values in components:
   - Bad: const response = await fetch('http://localhost:8005/api/...')
   - Bad: const API_URL = 'http://localhost:8005' in component files
   - Good: Create a dedicated config file that loads from environment

2. Use environment-aware configuration:
   - Create config files for different environments (dev, prod)
   - Use environment variables for sensitive or deployment-specific values
   - Example structure:
     ```
     /config
       config.ts         # Base config interface
       config.dev.ts     # Development overrides
       config.prod.ts    # Production overrides
     ```

3. Access config through a single source of truth:
   - Import config from ONE central location
   - Never duplicate config values across files
   - Makes it easy to modify values for all components

19. Keep Solutions Simple
-------------------------

1. Don't overcomplicate simple requirements:
   - Bad: Creating new tables for a simple reference
   - Bad: Adding complex joins when a simple property will do
   - Bad: Creating elaborate schemas for basic relationships
   - Good: Adding a nullable property to reference another model
   - Good: Using existing relationships when possible

2. Signs you're overcomplicating:
   - Creating new tables when a field would do
   - Adding joins for simple lookups
   - Making complex schemas for basic features
   - Overthinking simple requirements