SQLite Migration Tips
====================

1. SQLite Limitations
-------------------
- SQLite DOES NOT support ALTER TABLE for:
  * Adding constraints (like NOT NULL)
  * Changing column types
  * Renaming columns
  * Dropping columns

2. Correct Migration Pattern for SQLite
------------------------------------
When needing to modify tables, ALWAYS use this pattern:
1. Drop temporary tables if they exist from previous failed migrations
2. Create new table with desired schema
3. Copy data from old table to new table (use COALESCE for NULL values)
4. Drop old table
5. Rename new table to original name

Example:
```python
# Clean up any failed migrations
op.execute('DROP TABLE IF EXISTS table_new')

# Create new table
op.create_table(
    'table_new',
    sa.Column('id', sa.Integer(), nullable=False),
    # ... other columns
)

# Copy data with NULL handling
op.execute('''
    INSERT INTO table_new 
    SELECT 
        id,
        COALESCE(nullable_field, default_value),
        other_field 
    FROM table
''')

# Drop old table
op.drop_table('table')

# Rename new table
op.rename_table('table_new', 'table')
```

3. DateTime Fields in SQLite
-------------------------
- Always use server_default for created_at and updated_at
- Correct format:
  ```python
  created_at = Column(DateTime(timezone=True), 
                     server_default=sa.text('CURRENT_TIMESTAMP'),
                     nullable=False)
  updated_at = Column(DateTime(timezone=True),
                     server_default=sa.text('CURRENT_TIMESTAMP'),
                     onupdate=sa.text('CURRENT_TIMESTAMP'),
                     nullable=False)
  ```

4. Foreign Keys
-------------
- Always specify ondelete behavior
- Example:
  ```python
  parent_id = Column(Integer, ForeignKey('parent.id', ondelete='CASCADE'))
  ```

5. Common Gotchas
---------------
- Always handle nullable fields explicitly with COALESCE in migrations
- Use Text type for long string fields
- Remember to create indexes where needed
- SQLite treats booleans as integers
- When adding NOT NULL constraints, provide default values for existing NULL data
- Always clean up temporary tables from failed migrations with DROP TABLE IF EXISTS

6. Model Creation
----------------
ALWAYS CHECK EXISTING MODELS BEFORE CREATING NEW ONES:
- The Metric model already exists in models/goal.py
- Don't create duplicate models in separate files
- Look through existing code thoroughly before making changes

7. Model Organization
-------------------
- Models should be defined in a single location to avoid duplicate table definitions in SQLAlchemy
- If a model is closely related to another (like Metric is to Goal), define it in the same file
- Import models through __init__.py to maintain clean imports (e.g., from ..models import Metric instead of from ..models.metric import Metric)

8. Component Naming Consistency
----------------------
- NEVER have multiple components that do the same thing with different names (e.g. EditTaskModal vs EditTaskDialog)
- Pick ONE clear, descriptive name and stick with it throughout the app
- Bad: Having EditTaskModal.tsx and EditTaskDialog.tsx doing the same thing
- Good: Pick EditTaskDialog.tsx and use it everywhere - the name describes what it does, not how it looks
- This makes the codebase more intuitive and prevents confusion when adding new features

9. Don't fucking rename anything unless specifically asked to and permission is given.

10. Metric model is in Goal model.

11. Alembic Migration Tips
----------------------
- When a migration fails, check for leftover temporary tables (e.g. tasks_new) from previous attempts and clean them up
- For SQLite migrations that modify tables:
  1. Create a new table with the desired schema
  2. Copy all data from old table to new, being explicit about column order
  3. Drop the old table
  4. Rename the new table to the original name
- Index names must be unique across the entire database
- Always handle both upgrade() and downgrade() paths in migrations
- Test migrations on a copy of the database first
- When copying data between tables, explicitly list all columns to avoid issues with schema changes

12. SCHEMA CHANGES:
- NEVER change a schema unless a property literally doesn't exist
- Instead of changing schemas, use helper functions/properties to adapt the data
- Migrations are WAY more complicated and risky than just adapting the data in code
- If data format needs to change, handle it in the service layer, not by modifying the schema

13. API Endpoint Design
---------------------

1. DO NOT create separate endpoints for variations of the same action
   BAD: 
   - /tasks/{id}/update
   - /tasks/{id}/complete (for tasks with metrics)
   - /tasks/{id}/complete-simple (for tasks without metrics)
   
   GOOD:
   - Single /tasks/{id} PUT endpoint that handles all update cases
   - Let the payload determine what gets updated (completion status, metric data, etc.)

2. Keep the API surface minimal and consistent
   - One resource = One endpoint
   - Use HTTP methods (GET, POST, PUT, DELETE) to differentiate actions
   - Let request/response schemas handle variations in data

3. Example:
   Instead of special /complete endpoint, just use PUT with all necessary data:
   PUT /tasks/{id}
   {
     "completed": true,
     "metric_id": 123,        // Optional
     "contribution_value": 5   // Optional
   }

14. Database and Scripts
---------------------

1. Database file location:
   - The app uses SQLite with file: ./sql_app.db
   - When writing scripts, ALWAYS use the same database file as the main app:
     ```python
     DATABASE_URL = "sqlite:///./sql_app.db"  # NOT some other random path
     ```
   - If your script can't find tables, you're probably looking at the wrong database file

2. Writing Database Scripts:
   - Import all related models (including ones used in relationships)
   - Create tables if they don't exist: Base.metadata.create_all(bind=engine)
   - Use the same database URL as the main app
   - Test the script with a small subset of data first

15. Before Adding New Features
-------------------------

1. ALWAYS check if the functionality already exists:
   - Search through the codebase for relevant endpoints and components
   - Check both frontend and backend implementations
   - Look for similar patterns that might already handle the use case
   - Don't waste time implementing something that's already there

2. If adding new functionality:
   - Document where you looked and what's missing
   - Explain why the existing code can't handle the use case
   - Then proceed with the implementation

16. Function Naming Consistency
-------------------------

1. Keep function names consistent with their purpose and UI:
   - If a button says "Edit", the handler should be "handleEdit..."
   - If a button says "Add", the handler should be "handleAdd..."
   - Don't introduce new variations like "create", "save", "update" for the same action
   - Bad: handleCreateStrategy when the UI says "Add Strategy"
   - Good: handleAddStrategy for "Add Strategy" button
   - Good: handleEditStrategy for "Edit Strategy" button

2. Follow the established pattern in the codebase:
   - Look at similar features to maintain consistency
   - Don't mix different naming conventions for the same type of action

17. API Endpoints and URLs
-------------------------

1. NEVER hardcode URLs or API endpoints:
   - Don't use absolute URLs like "http://localhost:8005/api/..."
   - Use relative URLs like "/api/..." that will work in any environment
   - This ensures the app can be deployed without code changes

2. Be consistent with URL patterns:
   - Use the same URL structure throughout the application
   - If using relative URLs, use them everywhere
   - Don't mix relative and absolute URLs

18. Configuration Management
-------------------------

1. NEVER hardcode configuration values in components:
   - Bad: const response = await fetch('http://localhost:8005/api/...')
   - Bad: const API_URL = 'http://localhost:8005' in component files
   - Good: Create a dedicated config file that loads from environment

2. Use environment-aware configuration:
   - Create config files for different environments (dev, prod)
   - Use environment variables for sensitive or deployment-specific values
   - Example structure:
     ```
     /config
       config.ts         # Base config interface
       config.dev.ts     # Development overrides
       config.prod.ts    # Production overrides
     ```

3. Access config through a single source of truth:
   - Import config from ONE central location
   - Never duplicate config values across files
   - Makes it easy to modify values for all components

19. Keep Solutions Simple
-------------------------

1. Don't overcomplicate simple requirements:
   - Bad: Creating new tables for a simple reference
   - Bad: Adding complex joins when a simple property will do
   - Bad: Creating elaborate schemas for basic relationships
   - Good: Adding a nullable property to reference another model
   - Good: Using existing relationships when possible

2. Signs you're overcomplicating:
   - Creating new tables when a field would do
   - Adding joins for simple lookups
   - Making complex schemas for basic features
   - Overthinking simple requirements

20. Adding New Properties to Existing Models Checklist:

1. Database Layer:
   - Add the column to the SQLModel/SQLAlchemy model (models/*.py)
   - Create an Alembic migration script
   - For SQLite: Use create_table -> copy -> drop -> rename pattern instead of ALTER TABLE
   - Test the migration both up and down

2. Schema Layer:
   - Add the field to all relevant Pydantic schemas (schemas/*.py):
     * Base schema (optional/required field)
     * Create schema (if needed for creation)
     * Update schema (usually as Optional)
     * Response schema (if different from base)

3. API Layer:
   - Update API endpoints to handle the new field
   - Add field validation if needed
   - Update response preparation functions
   - Test API endpoints with the new field

4. Frontend Layer:
   - Update TypeScript interfaces to include the new field
   - Add UI components to display the field
   - Add form inputs to edit the field
   - Update API calls to send/receive the field
   - Add any needed validation
   - Style new UI elements

5. Testing:
   - Test the complete flow from UI to database and back
   - Test edge cases (null values, invalid inputs)
   - Test any new validation rules

Common Gotchas:
- Remember to handle null/undefined values consistently
- Keep field names consistent across all layers
- Consider backwards compatibility
- Update all relevant documentation
- Consider the impact on existing data

21. NEVER DELETE EXISTING FUNCTIONALITY
    - Always preserve existing features when adding new ones
    - Test that old features still work after adding new ones
    - If changes are needed to existing code, adapt the new code to work with it
    - Document any changes to existing functionality

22. ADAPT NEW CODE TO EXISTING PATTERNS
    - Study the existing codebase structure before adding new features
    - Follow established naming conventions and patterns
    - Reuse existing components and utilities where possible
    - Keep consistent with existing UI/UX patterns

23. FastAPI Schema and Data Visibility
--------------------------------
If data appears to be "not saving" but the database tables and relationships are correct:
- Check the Pydantic schemas in schemas/*.py
- Make sure all relationships are defined in the schema classes
- Example: If Goal has conversations in SQLAlchemy but not in Pydantic schema:
  ```python
  # models/goal.py (SQLAlchemy)
  conversations = relationship("Conversation", back_populates="goal")
  
  # schemas/goal.py (Pydantic)
  class Goal(GoalBase):
      # Missing! Data won't show in API even if saved
      conversations: List[Conversation] = []
  ```
- The data may be saving correctly but not appearing in API responses
- Always check both database models AND Pydantic schemas when data seems missing

24. Alembic Migration Organization
--------------------------------
- Keep ALL migration files in alembic/versions/ directory
- NEVER leave migration files in the root backend directory
- Migration files follow the pattern: <revision_id>_<description>.py
- Each migration file represents a specific database schema change
- Migration files form a chain through their revision history
- Don't delete migration files unless you're sure you want to lose rollback capability
- If you accidentally create migrations in the wrong place:
  1. Check if they're duplicates of existing migrations in alembic/versions/
  2. If unique, move them to alembic/versions/
  3. If duplicates, delete them to avoid confusion

25. Deployment Checklist
===================

1. Database Migration
------------------
- Run the priority field migration script:
  ```
  python -m backend.migrations.convert_priority_to_integer
  ```
- Verify that all task priorities are properly converted to integers
- Check that the Pydantic models correctly handle the integer-to-enum conversion

2. Environment Variables
--------------------
- Set ENVIRONMENT=production in production environment
- Set APP_VERSION to the current version number
- Make sure DATABASE_URL is properly configured with SSL settings
- Remove any debug-specific environment variables

3. CORS Configuration
-----------------
- Verify that the CORS origins are properly set for production
- Remove the wildcard (*) origin in production
- Test CORS with actual frontend domains

4. Health Check
------------
- Configure your deployment platform to use the /health endpoint
- Set appropriate health check intervals and timeout settings
- Monitor the health check endpoint for any issues

5. Database Connection
------------------
- Verify that connection pooling is properly configured
- Monitor for connection reset errors
- Set appropriate pool size based on expected load
- Configure connection timeouts appropriately

6. Performance Monitoring
---------------------
- Set up logging to capture any database or API errors
- Monitor API response times
- Watch for any priority enum conversion errors
- Check for detached instance errors in the logs

PostgreSQL Migration Tips
========================

1. Database Connection
--------------------
- Use environment variables for all database connection parameters
- Implement connection pooling for better performance
- Set appropriate connection timeouts and retry logic
- Test connections with both development and production settings
- Use SSL for secure connections in production

2. SQLAlchemy ORM Considerations
------------------------------
- Always convert UUID objects to strings when comparing IDs
- Use fresh database sessions when loading related objects to avoid detached instance errors
- Convert SQLAlchemy model objects to dictionaries before returning from API endpoints
- Implement proper error handling for database operations
- Use explicit joins instead of relying on lazy loading when possible

3. Data Type Compatibility
------------------------
- PostgreSQL has stricter type enforcement than SQLite
- Use proper enum types in PostgreSQL (create custom types if needed)
- Handle JSON/JSONB fields appropriately
- Ensure timestamp fields include timezone information
- Test numeric field precision and scale

4. Migration Strategy
------------------
- Create a complete backup of SQLite data before migration
- Use Alembic for managing schema migrations
- Test migrations on a development database before production
- Implement data validation before and after migration
- Consider a phased migration approach for large datasets

5. Common PostgreSQL Issues
------------------------
- Detached instance errors when accessing related objects across sessions
- UUID comparison issues (string vs. UUID object)
- Enum type mismatches between SQLite and PostgreSQL
- Connection pool exhaustion under heavy load
- Transaction isolation level differences

6. Performance Optimization
------------------------
- Create appropriate indexes for frequently queried fields
- Use connection pooling with appropriate settings
- Implement query optimization for complex joins
- Consider using PostgreSQL-specific features like materialized views
- Monitor query performance and optimize slow queries